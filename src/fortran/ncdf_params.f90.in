! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! +                                                           +
! +  glimmer_outp.f90 - part of the GLIMMER ice model         + 
! +                                                           +
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! 
! Copyright (C) 2004 GLIMMER contributors - see COPYRIGHT file 
! for list of contributors.
!
! This program is free software; you can redistribute it and/or 
! modify it under the terms of the GNU General Public License as 
! published by the Free Software Foundation; either version 2 of 
! the License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, 
! but WITHOUT ANY WARRANTY; without even the implied warranty of 
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License 
! along with this program; if not, write to the Free Software 
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
! 02111-1307 USA
!
! GLIMMER is maintained by:
!
! Ian Rutt
! School of Geographical Sciences
! University of Bristol
! University Road
! Bristol
! BS8 1SS
! UK
!
! email: <i.c.rutt@bristol.ac.uk> or <ian.rutt@physics.org>
!
! GLIMMER is hosted on NeSCForge:
!
! http://forge.nesc.ac.uk/projects/glimmer/
!
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

module glimmer_ncparams
  !*FD read netCDF I/O related configuration files
  !*FD written by Magnus Hagdorn, May 2004
  use glimmer_ncdf, only: glimmer_nc_meta
    
  private
  public :: ReadNCParams

  type(glimmer_nc_meta),save :: default_metadata

contains
  subroutine ReadNCParams(model,config)
    !*FD read netCDF I/O related configuration file
    use glide_types
    use glimmer_config
    implicit none
    type(glide_global_type)      :: model  !*FD model instance
    type(ConfigSection), pointer :: config !*FD structure holding sections of configuration file
    
    ! local variables
    type(ConfigSection), pointer :: section
    type(glimmer_nc_output), pointer :: output => null()
    type(glimmer_nc_input), pointer :: input => null()

    ! get default meta data
    call GetSection(config,section,'default')
    if (associated(section)) then
       call handle_metadata(section, default_metadata, .true.)
    end if

    ! setup outputs
    call GetSection(config,section,'output')
    do while(associated(section))
       output => handle_output(section,output)
       if (.not.associated(model%funits%out_first)) then
          model%funits%out_first => output
       end if
       call GetSection(section%next,section,'output')
    end do

    ! setup inputs
    call GetSection(config,section,'input')
    do while(associated(section))
       input => handle_input(section,input)
       if (.not.associated(model%funits%in_first)) then
          model%funits%in_first => input
       end if
       call GetSection(section%next,section,'input')
    end do

  end subroutine ReadNCParams

  !==================================================================================
  ! private procedures
  !==================================================================================

  subroutine handle_metadata(section,metadata, default)
    use glimmer_ncdf
    use glimmer_config
    use glimmer_global, only: glimmer_version
    implicit none
    type(ConfigSection), pointer :: section
    type(glimmer_nc_meta) ::metadata
    logical :: default

    ! local variables
    character(len=8) :: date
    character(len=10) :: time

    if (.not.default) then
       metadata%title = trim(default_metadata%title)
       metadata%institution = trim(default_metadata%institution)
       metadata%references = trim(default_metadata%references)
       metadata%comment = trim(default_metadata%comment)
    end if

    call GetValue(section,'title',metadata%title)
    call GetValue(section,'institution',metadata%institution)
    call GetValue(section,'references',metadata%references)
    call GetValue(section,'comment',metadata%comment)

    if (default) then
       call date_and_time(date,time)
       metadata%source = 'Generated by '//trim(glimmer_version)
       write(metadata%history,fmt="(a4,'-',a2,'-',a2,' ',a2,':',a2,':',a6,' : ',a)") date(1:4),date(5:6),date(7:8),&
            time(1:2),time(3:4),time(5:10),trim(glimmer_version)
    else
       metadata%source = trim(default_metadata%source)
       metadata%history = trim(default_metadata%history)
    end if
  end subroutine handle_metadata

  function handle_output(section, output)
    use glimmer_ncdf
    use glimmer_config
    use glimmer_log
    implicit none
    type(ConfigSection), pointer :: section
    type(glimmer_nc_output), pointer :: output
    type(glimmer_nc_output), pointer :: handle_output
    character(len=100) :: message
    ! local variables
    character(len=210) vars
    integer :: numspots=-1

    handle_output=>add(output)
    
    ! get filename
    call GetValue(section,'name',handle_output%nc%filename)
    call GetValue(section,'frequency',handle_output%freq)
    call GetValue(section,'variables',vars)
    call GetValue(section,'numspot',numspots)
    if (numspots.eq.-1) then
       numspots=100
    end if
    call GetValue(section,'spotx',handle_output%spotx,numspots)
    call GetValue(section,'spoty',handle_output%spoty,numspots)

    ! get metadata
    call handle_metadata(section, handle_output%metadata,.false.)

    if (associated(handle_output%spotx) .and. associated(handle_output%spoty)) then
       if (size(handle_output%spotx).ne.size(handle_output%spoty)) then
          write(message,*) 'Warning [netCDF output]  number of spot x and y locations differ ', &
               size(handle_output%spotx), size(handle_output%spoty)
          call write_log(trim(message))
       else
          handle_output%nc%do_spot = .true.
       end if
    end if
    
    vars = ' '//trim(vars)//' '

    if (handle_output%nc%filename(1:1).eq.' ') then
       call error_log('Error, no file name specified [netCDF output]')
       stop
    end if

    ! select which variables should be written
    !GENVARS!
  end function handle_output
  
  function handle_input(section, input)
    use glimmer_ncdf
    use glimmer_config
    use glimmer_log
    implicit none
    type(ConfigSection), pointer :: section
    type(glimmer_nc_input), pointer :: input
    type(glimmer_nc_input), pointer :: handle_input

    handle_input=>add(input)
    
    ! get filename
    call GetValue(section,'name',handle_input%nc%filename)
    call GetValue(section,'time',handle_input%get_time_slice)
    
    handle_input%current_time = handle_input%get_time_slice

    if (handle_input%nc%filename(1:1).eq.' ') then
       call error_log('Error, no file name specified [netCDF input]')
       stop
    end if
  end function handle_input
end module glimmer_ncparams
